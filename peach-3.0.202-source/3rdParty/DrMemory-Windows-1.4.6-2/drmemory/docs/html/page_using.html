<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>Dr. Memory: Using Dr. Memory</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
<link href="tabs.css" rel="stylesheet" type="text/css">
<link rel="shortcut icon" type="image/x-icon" href="favicon.ico" />
</head><body>
<!-- Generated by Doxygen 1.6.1 -->
<div class="contents">


<h1><a class="anchor" id="page_using">Using Dr. Memory </a></h1><p>This section gives an overview of how to use Dr. Memory, divided into the following sub-sections:</p>
<ul>
<li><a class="el" href="page_using.html#sec_linux">Setup on Linux</a></li>
<li><a class="el" href="page_using.html#sec_windows">Setup on Windows</a></li>
<li><a class="el" href="page_using.html#sec_running">Running Dr. Memory</a></li>
<li><a class="el" href="page_using.html#sec_errors">Error Types Reported by Dr. Memory</a><ul>
<li><a class="el" href="page_using.html#sec_unaddr">Unaddressable Access</a></li>
<li><a class="el" href="page_using.html#sec_uninit">Uninitialized Read</a></li>
<li><a class="el" href="page_using.html#sec_invarg">Invalid Heap Argument</a></li>
<li><a class="el" href="page_using.html#sec_leaks">Memory Leaks</a></li>
<li><a class="el" href="page_using.html#sec_warning">Warning</a></li>
</ul>
</li>
</ul>
<p>See also the full reference of Dr. Memory's runtime options:</p>
<ul>
<li><a class="el" href="page_options.html">Dr. Memory Runtime Option Reference</a></li>
</ul>
 
<table width=100% bgcolor="#000000" cellspacing=0 cellpadding=2 border=0>
  <tr><td><table width=100% bgcolor="#0000C0" cellspacing=0 cellpadding=1 border=0>
  <tr><td><table width=100% bgcolor="#0000C0" cellspacing=0 cellpadding=1 border=0>
  <tr><td></td></tr></table></td></tr></table></td></tr></table>
 <h2><a class="anchor" id="sec_linux">
Setup on Linux</a></h2>
<p>This section describes requirements, setup instructions, and other concerns prior to running Dr. Memory on Linux.</p>
<h3><a class="anchor" id="sec_linux_utils">
Utilities</a></h3>
<p>Ensure your Linux machine has the following utilities installed:</p>
<ul>
<li>perl</li>
<li>objdump</li>
<li>addr2line</li>
</ul>
 
<table width=100% bgcolor="#000000" cellspacing=0 cellpadding=2 border=0>
  <tr><td><table width=100% bgcolor="#0000C0" cellspacing=0 cellpadding=1 border=0>
  <tr><td><table width=100% bgcolor="#0000C0" cellspacing=0 cellpadding=1 border=0>
  <tr><td></td></tr></table></td></tr></table></td></tr></table>
 <h2><a class="anchor" id="sec_windows">
Setup on Windows</a></h2>
<p>This section describes requirements, setup instructions, and other concerns prior to running Dr. Memory on Windows.</p>
<p>Please note that Dr. Memory does not yet have full support for the Windows graphical system calls, leading to extra false positives, particularly on Windows Vista and Windows 7. Future releases will eliminate these; for now, suppression files can be used.</p>
<h3><a class="anchor" id="sec_windows_utils">
Utilities</a></h3>
<p>Dr. Memory displays results using <code>notepad</code> by default. If it is not on the PATH a message pointing to the file containing the results will be displayed. The option <code>-batch</code> can be used to disable the launch of <code>notepad</code> at application exit.</p>
<h3><a class="anchor" id="sec_windows_cygwin">
Dr. Memory and MinGW or Cygwin</a></h3>
<p>Dr. Memory supports applications compiled with the MinGW gcc or g++ compilers, but will only provide line number information if DWARF2 debugging information is present. The default for MinGW gcc prior to version 4.3 is to use the stabs format, which is not supported by Dr. Memory. Pass the -ggdb option to gcc to generate DWARF2 format instead.</p>
<p>For MinGW C++ applications, Dr. Memory also requires the use of static libstdc++ libraries. Pass "-static-libgcc -static-libstdc++" to g++ to request this. Since these static libraries contain frame pointer optimizations, we recommend passing the "-no_callstack_use_top_fp" runtime option to Dr. Memory. This option is also discussed below. Dr. Memory attempts to automatically use this setting when it executes an application built with MinGW.</p>
<p>Currently there is no support for applications built with Cygwin gcc.</p>
<p>The regular Dr. Memory build can be executed just fine from a Cygwin shell when targeting non-Cygwin applications.</p>
 
<table width=100% bgcolor="#000000" cellspacing=0 cellpadding=2 border=0>
  <tr><td><table width=100% bgcolor="#0000C0" cellspacing=0 cellpadding=1 border=0>
  <tr><td><table width=100% bgcolor="#0000C0" cellspacing=0 cellpadding=1 border=0>
  <tr><td></td></tr></table></td></tr></table></td></tr></table>
 <h2><a class="anchor" id="sec_running">
Running Dr. Memory</a></h2>
<p>The first step is to unzip or untar the Dr. Memory package.</p>
<h3><a class="anchor" id="sec_app_prep">
Prepare Your Application</a></h3>
<p>In order to obtain line number information, compile your target application with debugging information enabled (e.g., "/Zi" for cl.exe or "-g" for gcc or g++).</p>
<p>On Linux, Dr. Memory supports ELF files with DWARF2 line information. On Windows, Dr. Memory supports PDB debug information (produced by Visual Studio). The Windows release of Dr. Memory does not support symbols for applications built with gcc or g++ on Windows.</p>
<p>If you want to run your application with stripped libraries or binaries and have the unstripped versions in separate locations, you can point at those locations using the <code>DRMEMORY_LIB_PATH</code> environment variable, which is a colon-separated list of directories.</p>
<p>On Windows, the debug DLL C library (specified with the "/MDd" flag) is currently not supported. Instead, build your application with either the release DLL ("/MD") or the release or debug static library ("/MT" or "/MTd"), although "/MTd" is not recommended (see below). When using Visual Studio, the release library can be selected from Visual Studio's configuration dialog (press Alt-F7 to bring it up) under the C/C++ | Code Generation | Runtime Library settings. Change "Multi-threaded Debug DLL
(/MDd)" to "Multi-threaded DLL (/MD)". If your application is C++, another step is necessary when using /MD to avoid the C++ Debug DLL: under Configuration Properties | C/C++ | Preprocessor, remove "_DEBUG" from the list of "Preprocessor Definitions".</p>
<p>On Windows, when using debug versions of the C library (when building with the "/MTd" flag ("/MDd" is not supported at all), you will not be able to control the redzone size. The debug heap checks will mostly be disabled as they overlap and can conflict with Dr. Memory's checks. It is recommended that the release version of the heap routines be used. Additionally, when using static debug versions of msvcrt (the "/MTd" flag), if your application does not have symbols then Dr. Memory will not be able to identify and avoid conflicts with msvcrt's own heap debugging facilities, which may lead to false positives and/or false negatives. Be sure to build with debugging information included.</p>
<p>You'll get better callstacks in error reports if you disable inlining. For cl.exe, "/Ob0", or for gcc or g++, "-fno-inline". Dr. Memory should be able to determine callstacks in the presence of frame pointer optimizations (FPO) in most cases, but if you see strange callstacks in an optimized application consider disabling FPO: for cl.exe, "/Oy-"; for gcc or g++, "-fno-omit-frame-pointer".</p>
<p>If your application links with a static library that was built with frame pointer optimizations and you observe missing frames on your callstacks, try running with the option "-no_callstack_use_top_fp". This will add some additional overhead on malloc-intensive applications, but should eliminate skipped frames.</p>
<p>The Visual Studio compiler's /RTC1 flag can prevent Dr. Memory from reporting uninitialized reads of local variables, and the /RTC1 checks for uninitialized reads themselves may not catch everything that Dr. Memory finds. However, /RTC1 does perform additional stack checks that Dr. Memory does not, so for best results, your application should be run under Dr. Memory without /RTC1, and run natively with /RTC1.</p>
<h3><a class="anchor" id="sec_invocation">
Invoking Dr. Memory</a></h3>
<p>Run your application as you normally would from a command prompt (on Windows, either the <code>cmd</code> shell or a Cygwin prompt), with <code>drmemory.exe</code> and "--" prefixed to the command line (the "--" separates any arguments to Dr. Memory from the application being run).</p>
<dl class="user"><dt><b></b></dt><dd><code>~/DrMemory-Windows-1.4.6-1/bin/drmemory.exe -- c:/path/to/my/app args to my app </code></dd></dl>
<p>On Windows, if you used the installer and checked the box to add <code>drmemory.exe</code> to your PATH, you can simply type into your shell:</p>
<dl class="user"><dt><b></b></dt><dd><code>drmemory.exe -- c:/path/to/my/app args to my app </code></dd></dl>
<p>You can also drag-and-drop your application onto <code>drmemory.exe</code> in Windows Explorer or on the Desktop if you requested a Desktop shorcut upon installation.</p>
<p>When running scripts it is best to explicitly invoke the interpreter rather than invoking the script directly. For example:</p>
<dl class="user"><dt><b></b></dt><dd><code>~/DrMemory-Windows-1.4.6-1/bin/drmemory.exe -- /usr/bin/perl ./myscript.pl </code></dd></dl>
<h3><a class="anchor" id="sec_results">
Examining the Results</a></h3>
<p>Dr. Memory's results are written to a file called <code>results.txt</code> inside a subdirectory created for each invocation of Dr. Memory, inside Dr. Memory's log directory. The log directory by default is the <code>logs</code> subdirectory of the unpacked installation, or the Dr. Memory directory inside your profile directory when Dr. Memory is installed into Program Files on Windows. It can be changed with the <code>-logdir</code> option:</p>
<dl class="user"><dt><b></b></dt><dd><code>~/DrMemory-Windows-1.4.6-1/bin/drmemory.exe -logdir c:/logs -- myapp </code></dd></dl>
<p>When an application is executed under Dr. Memory's control, it creates a subdirectory in the base log directory named "DrMemory-&lt;appname&gt;.&lt;pid&gt;.NNN", where NNN is a counter that is incremented to ensure unique names.</p>
<p>On Windows, the results files is automatically opened in <code>notepad</code> when the application exits. This only occurs for the top-level process; if it created child processes, they will be followed by Dr. Memory and have their own result directories and files, but these will not be automatically displayed. The option <code>-batch</code> can be used to disable the launch of <code>notepad</code> at application exit.</p>
<p>For full details on the errors reported by Dr. Memory, see <a class="el" href="page_using.html#sec_errors">Error Types Reported by Dr. Memory</a>.</p>
<p>If you would like to attach a debugger at the point an error is first detected, use the <code>-pause_at_unaddressable</code> or <code>-pause_at_uninitialized</code> options (see <a class="el" href="page_options.html">Dr. Memory Runtime Option Reference</a>).</p>
<h3><a class="anchor" id="sec_children">
Controlling Child Processes</a></h3>
<p>By default, Dr. Memory monitors all child processes. To disable this behavior and not monitor any children, use this option:</p>
<dl class="user"><dt><b></b></dt><dd><code>~/DrMemory-Windows-1.4.6-1/bin/drmemory.exe -no_follow_children </code></dd></dl>
<p>To follow all children except certain applications, run this command with the executable name of each application you do not wish to monitor, prior to running Dr. Memory with default options:</p>
<dl class="user"><dt><b></b></dt><dd><code>~/DrMemory-Windows-1.4.6-1/bin/drconfig.exe -quiet -reg myapp -norun </code></dd></dl>
<p>This <code>-norun</code> request is permanent and affects all subsequent Dr. Memory executions by the user that issued the <code>-norun</code> request. To undo it, use this command:</p>
<dl class="user"><dt><b></b></dt><dd><code>~/DrMemory-Windows-1.4.6-1/bin/drconfig.exe -quiet -unreg myapp </code></dd></dl>
<h3><a class="anchor" id="sec_aggregate">
Aggregating Results From Multiple Processes</a></h3>
<p>Dr. Memory supports aggregating results from multiple log directories, whether from multiple processes of a multi-process application or from multiple runs of the same application. Simply use the <code>-aggregate</code> option and supply the list of log directories, or a single directory containing the log directories as sub-directories to aggregate all of them:</p>
<dl class="user"><dt><b></b></dt><dd><code>~/DrMemory-Windows-1.4.6-1/bin/drmemory.exe -aggregate DrMemory-myapp.1234.000 DrMemory-myapp.1235.000 </code></dd></dl>
<dl class="user"><dt><b></b></dt><dd><code>~/DrMemory-Windows-1.4.6-1/bin/drmemory.exe -aggregate /parent/logdir/ </code></dd></dl>
<h3><a class="anchor" id="sec_daemon">
Applications That Do Not Exit</a></h3>
<p>While Dr. Memory updates the <code>results.txt</code> file as the application runs, it does not perform leak checking or produce a summary of errors until the end of the run. For applications that do not have a normal exit, such as daemons, Dr. Memory provides a method of forcing end-of-run actions.</p>
<p>Run <code>drmemory.exe</code> with the <code>-nudge</code> option and the process identifier of the application in order to request leak checking and other end-of-run actions:</p>
<dl class="user"><dt><b></b></dt><dd><code>~/DrMemory-Windows-1.4.6-1/bin/drmemory.exe -nudge processid </code></dd></dl>
<h3><a class="anchor" id="sec_twostep">
Post-Run Symbol Processing</a></h3>
<p>Some applications have very large symbol files. To reduce resource usage during an application run, symbol processing can be disabled while the application executes and instead be performed after the run. Use the <code>-skip_results</code> option when running the application. Once finished, re-run Dr. Memory with the <code>-results</code> option and the log directory created during the run (which contains the raw data):</p>
<dl class="user"><dt><b></b></dt><dd><code>~/DrMemory-Windows-1.4.6-1/bin/drmemory.exe -skip_results -- myapp myargs </code></dd></dl>
<dl class="user"><dt><b></b></dt><dd><code>~/DrMemory-Windows-1.4.6-1/bin/drmemory.exe -results DrMemory-myapp.9876.000 </code></dd></dl>
<p>If <code>-results</code> is invoked on a different machine where the application executable is not located at the same path as when it was executed with <code>-skip_results</code>, use the <code>-results_app</code> parameter to specify the executable along with the <code>-results</code> parameter.</p>
<p>The <code>-skip_results</code> option is not currently available on Windows.</p>
<h3><a class="anchor" id="sec_syslib_syms">
System Library Symbols</a></h3>
<p>On Linux, Dr. Memory will look in the default debug directories for symbols for a library: a <code>.debug</code> subdirectory of the library's directory or in <code>/usr/lib/debug</code>.</p>
<p>On Windows, the <code>_NT_SYMBOL_PATH</code> environment variable is honored by Dr. Memory as a local cache of <code>pdb</code> files. However, Dr. Memory does not support symbol store paths (those that contain <code>srv</code>).</p>
<h3><a class="anchor" id="sec_suppress">
Suppressing Errors</a></h3>
<p>Dr. Memory generates a file named <code>suppress.txt</code> alongside the <code>results.txt</code> file. To suppress errors from being reported in future runs, edit this file to contain just the errors you wish to suppress. Then pass the file to <code>drmemory.exe</code> with the -suppress option:</p>
<dl class="user"><dt><b></b></dt><dd><code>~/DrMemory-Windows-1.4.6-1/bin/drmemory.exe -suppress c:/suppress-custom.txt -- myapp </code></dd></dl>
<p>The suppress.txt generated by Dr. Memory will contain suppression information only for those errors that weren't suppressed using the -suppress option. For each error reported in suppress.txt, there will be two types of call stacks, one showing <code>&lt;module+offset&gt;</code> type frames and the other <code>module!function</code> type frames. The offset in <code>&lt;module+offset&gt;</code> must be a lower-case hexadecimal constant (e.g., <code>0x4af</code>) and is the offset from the start of the module. Either type of call stack can be used and it is enough if one of those two is specified. The <code>module!function</code> are more general and more robust across different versions of a module.</p>
<p>In order to simplify writing suppressions, callstacks support "*" and "?" wildcards in either the module or function name (or offset for <code>&lt;module+offset&gt;</code>). A "*" matches any number of characters of any kind. A "?" matches a single character of any kind. C++ functions should be in their unmangled form. If a literal "*" is desired, a "?" should usually be used instead to avoid the "*" wildcard expansion.</p>
<p>To match any frame at all, use a single "*". To match any module but not any non-module (and thus not match a system call or non-module code, such as generated code), use "*!*".</p>
<p>Callstacks automatically employ prefix matching. Prefix matching means that the callstack in the suppression file is considered a match if it matches the top of any actual callstack during a run. This allows specifying only the first few frames of a callstack and have it match any callstack whose first frames match those frames, regardless of subsequent frames.</p>
<p>A final type of wildcard frame is supported: "...". A callstack frame consisting of the string "..." matches zero or more frames in the callstack.</p>
<p>As a variation on the "..." ellipsis frame, "module!..." matches one or more frames in a given module. Importantly, it will not match zero frames like a plain ellipsis. This form is most useful for suppressing reports through system libraries that are missing symbols, because oftentimes such reports can be identified by the way they call back and forth across system library boundaries.</p>
<p>Suppression files can have empty lines and comment lines (begining with #). There should be no leading white space for the actual suppression information. Suppressions should not end with "...", which is unnecessary due to the implicit prefix matching.</p>
<p>A suppression can be given an identifier with a <code>name=</code> line after the error type line. Suppressions that were matched are printed in the results file with a count of how many unique callstacks were matched. Duplicate callstacks are not included. Here is an example:</p>
<div class="fragment"><pre class="fragment">LEAK
name=bug #456 (deliberately leaked object)
mylib.dll!LeakMe
mylib.dll!*
</pre></div><p>On Windows, for unaddressable accesses and uninitialized reads, a suppression can be further restricted by the actual instruction involved. The instruction is printed out in an error report in a <code>Note:</code> field. For example: </p>
<div class="fragment"><pre class="fragment">Error #8: UNADDRESSABLE ACCESS: reading 0x001338a8-0x001338ac 4 byte(s)
...
Note: instruction: mov    (%eax) -&gt; %eax
</pre></div><p>A suppression can contain an <code>instruction=</code> line after the error type line which will be matched against this note field. It can contain wildcards. The <code>instruction=</code> line is currently ignored on Linux. Here is an example:</p>
<div class="fragment"><pre class="fragment">UNINITIALIZED READ
name=bug #123 (deliberate uninitialized read to generate random number)
instruction=test   * $0x00000?00
myranlib.dll!GenRanHelper*
myranlib.dll!GenRan*
</pre></div><p>For users with existing Valgrind Memcheck suppression files, Dr. Memory supports Valgrind-style suppressions, but not with mangled C++ symbols. On Linux, a script called <code>valgrind2drmemory.pl</code> is provided in the bin directory that can be used to convert a legacy Valgrind suppression file to the Dr. Memory format. It uses heuristics to convert mangled C++ symbols that contain wildcards and may not succeed on complex types (it prints a warning for those it fails on). Use it like this:</p>
<div class="fragment"><pre class="fragment">bin/valgrind2drmemory.pl /path/to/old-supp-file /path/to/<span class="keyword">new</span>-drmem-towrite
</pre></div><p>The Dr. Memory suppression format is more powerful then the Valgrind format and matches the Windows module!function standards used by other tools. We recommend converting to the Dr. Memory format from a legacy format.</p>
<p>Another method of ignoring errors is to filter the reported errors to focus on particular source files. Use the <code>-srcfilter</code> option to do this:</p>
<dl class="user"><dt><b></b></dt><dd><code>~/DrMemory-Windows-1.4.6-1/bin/drmemory.exe -srcfilter hello.c -- ./hello </code></dd></dl>
<p>The <code>-srcfilter</code> option is not available in the Windows version of Dr. Memory.</p>
<p>Dr. Memory comes with a set of default suppressions to avoid known false positives in system libraries. These can be disabled with the option -no_default_suppress.</p>
<h3><a class="anchor" id="sec_replace">
Replaced Routines</a></h3>
<p>Dr. Memory replaces several string and memory routines in the C library, executable, and other libraries, in order to avoid false positives from extremely-optimized versions of these routines. So if an application expects a crash inside a routine like <code>strlen</code>, do not be alarmed if it shows up as <code>replace_strlen</code> in the Dr. Memory library rather than <code>strlen</code> in the C library.</p>
 
<table width=100% bgcolor="#000000" cellspacing=0 cellpadding=2 border=0>
  <tr><td><table width=100% bgcolor="#0000C0" cellspacing=0 cellpadding=1 border=0>
  <tr><td><table width=100% bgcolor="#0000C0" cellspacing=0 cellpadding=1 border=0>
  <tr><td></td></tr></table></td></tr></table></td></tr></table>
 <h2><a class="anchor" id="sec_errors">
Error Types Reported by Dr. Memory</a></h2>
<p>Each error found by Dr. Memory is listed in the <code>results.txt</code> file (see <a class="el" href="page_using.html#sec_results">Examining the Results</a>). The error report includes an error number, the type of error, the address and size of the memory access in question (if applicable to the error type), a timestamp and thread identifier indicating when and where the error was detected, and a callstack of the application at the point of the error. The thread identifier can be correlated with the function of a particular thread by locating the thread creation callstack in the <code>global.pid.log</code> file in the same directory as the <code>results.txt</code> file.</p>
<p>The <code>-brief</code> option can be used to request simpler and in some cases easier to read (i.e., more suited to novices) error reports that hide STL and CRT paths, simplify source paths for the executable by removing the path containing the executable itself, and omit absolute addresses, thread timestamps, and instruction disassembly.</p>
<p>The following subsections describe each type of error. Leaks are described in <a class="el" href="page_using.html#sec_leaks">Memory Leaks</a>.</p>
<h3><a class="anchor" id="sec_unaddr">
Unaddressable Access</a></h3>
<p>Dr. Memory considers any read or write of a memory location that was not allocated as an "unaddressable access". An allocation is:</p>
<ul>
<li>A call to mmap (or mremap) (or Windows equivalents VirtualAlloc or MapViewOfFile) outside of a heap or stack region.</li>
<li>A call to malloc (or calloc or realloc, or Windows equivalents HeapAlloc or HeapReAlloc or the Local or Global versions) inside of a heap region</li>
<li>An extension of the stack in a stack region, either via raw instructions or via alloca.</li>
</ul>
<p>An unaddressable access is an access to an invalid memory address. Examples include a buffer overflow, reading off the end of an array, reading or writing to memory that has been freed (often referred to as a "use-after-free" error), reading beyond the top of the stack, etc.</p>
<p>The heap allocator may pad the size requested by the application. The padded region beyond what the application asked for is considered unaddressable by Dr. Memory.</p>
<p>Consider this example code: </p>
<div class="fragment"><pre class="fragment"><span class="keywordtype">char</span> *x = malloc(8);
<span class="keywordtype">char</span> c = *(x+8);
</pre></div><p>Here is a diagram of the resulting heap allocation:  
<table cellspacing=0 cellpadding=10 border=0>
<tr><td align="right">malloc header:</td>
    <td bgcolor="#fcd6a5" width=50>unaddressable</td></tr>
<tr><td align="right">x:            </td>
    <td bgcolor="#a7d588" width=50>uninitialized</td></tr>
<tr><td align="right">x + 8:        </td>
    <td bgcolor="#fcd6a5" width=50>unaddressable</td></tr></td></tr>
</table>
<p>Dr. Memory will report an unaddressable access error on the second line of the example code, because <code>x+8</code> is not an addressable location.</p>
<p>When an unaddressable access occurs in a heap region, Dr. Memory attempts to provide additional information about nearby valid allocations and whether the target address is inside a region that has been freed. For example, here is a sample error report:</p>
<div class="fragment"><pre class="fragment">Error #1: UNADDRESSABLE ACCESS: reading 0x000a720b-0x000a720c 1 byte(s)
<span class="preprocessor"># 0 main                            [e:\derek\drmemory\git\src\tests\malloc.c:96]</span>
<span class="preprocessor"></span>Note: @0:00:01.500 in thread 3808
Note: refers to 1 byte(s) beyond last valid byte in prior malloc
Note: prev lower malloc:  0x000a7208-0x000a720b
Note: instruction: mov    0x03(%edx) -&gt; %al
</pre></div><p>Note how the "prev lower malloc" ends at 0x000a720b just before the invalid address, indicating a read that went one byte too far, as indicated.</p>
<p>Here is another example, using the <code>-delay_frees_stack</code> option to obtain the callstack of the freed memory:</p>
<div class="fragment"><pre class="fragment">Error #8: UNADDRESSABLE ACCESS: reading 0x001338a8-0x001338ac 4 byte(s)
<span class="preprocessor"># 0 unaddr_test1                    [e:\derek\drmemory\git\src\tests\suppress.c:110]</span>
<span class="preprocessor"></span><span class="preprocessor"># 1 test                            [e:\derek\drmemory\git\src\tests\suppress.c:269]</span>
<span class="preprocessor"></span><span class="preprocessor"># 2 main                            [e:\derek\drmemory\git\src\tests\suppress.c:297]</span>
<span class="preprocessor"></span>Note: @0:00:02.141 in thread 3024
Note: next higher malloc: 0x001338e8-0x00133938
Note: prev lower malloc:  0x001337e8-0x00133820
Note: 0x001338a8-0x001338ac overlaps memory 0x001338a8-0x001338c4 that was freed here:
Note: # 0 test                            [e:\derek\drmemory\git\src\tests\suppress.c:269]
Note: # 1 main                            [e:\derek\drmemory\git\src\tests\suppress.c:297]
Note: instruction: mov    (%eax) -&gt; %eax
</pre></div><p>The <code>-brief</code> option provides less information but may be easier to read:</p>
<div class="fragment"><pre class="fragment">Error #8: UNADDRESSABLE ACCESS: reading 4 byte(s)
<span class="preprocessor"># 0 unaddr_test1                    [e:\derek\drmemory\git\src\tests\suppress.c:110]</span>
<span class="preprocessor"></span><span class="preprocessor"># 1 test                            [e:\derek\drmemory\git\src\tests\suppress.c:269]</span>
<span class="preprocessor"></span><span class="preprocessor"># 2 main                            [e:\derek\drmemory\git\src\tests\suppress.c:297]</span>
<span class="preprocessor"></span>Note: refers to memory that was freed here:
Note: # 0 test                            [e:\derek\drmemory\git\src\tests\suppress.c:269]
Note: # 1 main                            [e:\derek\drmemory\git\src\tests\suppress.c:297]
</pre></div><p>The <code>callstack_style</code> option can be used to customize how callstacks are printed out. Here is another style for the same callstack (without -brief):</p>
<div class="fragment"><pre class="fragment">Error #8: UNADDRESSABLE ACCESS: reading 0x001338a8-0x001338ac 4 byte(s)
<span class="preprocessor"># 0 unaddr_test1 (0x0040130b &lt;suppress.exe+0x130b&gt;)</span>
<span class="preprocessor"></span>    e:\derek\drmemory\git\src\tests\suppress.c:110
<span class="preprocessor"># 1 test (0x0040112d &lt;suppress.exe+0x112d&gt;)</span>
<span class="preprocessor"></span>    e:\derek\drmemory\git\src\tests\suppress.c:269
<span class="preprocessor"># 2 main (0x0040107e &lt;suppress.exe+0x107e&gt;)</span>
<span class="preprocessor"></span>    e:\derek\drmemory\git\src\tests\suppress.c:297
Note: @0:00:01.453 in thread 4088
Note: next higher malloc: 0x001338e8-0x00133938
Note: prev lower malloc:  0x001337e8-0x00133820
Note: 0x001338a8-0x001338ac overlaps memory 0x001338a8-0x001338c4 that was freed here:
Note: # 0 test (0x00401121 &lt;suppress.exe+0x1121&gt;)
Note:     e:\derek\drmemory\git\src\tests\suppress.c:269
Note: <span class="preprocessor"># 1 main (0x0040107e &lt;suppress.exe+0x107e&gt;)</span>
<span class="preprocessor"></span>Note:     e:\derek\drmemory\git\src\tests\suppress.c:297
Note: instruction: mov    (%eax) -&gt; %eax
</pre></div><p>In this case Dr. Memory is able to report that the target address is inside a malloc area that has been freed and has not been re-allocated since.</p>
<p>This additional information, and the addresses accessed, only apply to the first error with that callstack that Dr. Memory sees. Any subsequent errors with the same callstack will increment the duplicate count for that error <em>but further individual information about each duplicate is not provided</em>.</p>
<h3><a class="anchor" id="sec_uninit">
Uninitialized Read</a></h3>
<p>If the application reads from addressable memory that has not been written to since it was allocated, Dr. Memory reports an "uninitialized read" error. In order to avoid false positives, Dr. Memory does not report the use of uninitialized memory until something "meaningful" is done with that memory, such as a comparison or conditional branch or passing it to a system call. Variables or fields smaller than a word are often initialized without their containing word (variables and fields are typically word-aligned) being initialized. When these variables or fields are then copied, the uninitialized portion of each word is technically being read as an uninitialized value, but reporting such reads as errors would result in far too many errors.</p>
<p>When passing data structures to a system call, if the structure is initialized field-by-field then padding bytes may be left uninitialized. Dr. Memory will report errors on these as it does not know whether the kernel or a receipient on the other end might read it. To avoid these errors, memset the entire structure, or use a Dr. Memory error suppression (see <a class="el" href="page_using.html#sec_suppress">Suppressing Errors</a>) to ignore the error.</p>
<p>Here is an example of an uninitialized read error:</p>
<div class="fragment"><pre class="fragment">Error #2: UNINITIALIZED READ: reading 0xffbae108-0xffbae114 12 byte(s) within 0xffbae100-0xffbae114
Elapsed time = 0:00:00.214 in thread 19298
system call socketcall setsockopt args
    &lt;system call&gt;
0x08049a65 &lt;my-socket-test+0x1a65&gt; my-socket-test!main
    ??:0
0x0092dbb6 &lt;libc.so.6+0x16bb6&gt; libc.so.6&lt;nosyms&gt;!__libc_start_main
    ??:0
0x080489b1 &lt;my-socket-test+0x9b1&gt; my-socket-test!_start
    ??:0
</pre></div><p>When only part of a larger region is uninitialized, Dr. Memory reports the containing range to make it easier to track down the problem. This typically happens with buffers or structures passed to system calls. Note also in this example how Dr. Memory reports which part of the socketcall system call checks discovered this error.</p>
<h3><a class="anchor" id="sec_invarg">
Invalid Heap Argument</a></h3>
<p>Whenever a pointer that does not refer to a valid malloc region is passed to free() or other malloc-related routines, Dr. Memory reports an "invalid
heap argument" error. Here the problem is immediately apparent as 0x00001234 is not a valid heap address at all:</p>
<div class="fragment"><pre class="fragment">Error #4: INVALID HEAP ARGUMENT: free 0x00001234
Elapsed time = 0:00:00.180 in thread 21848
<span class="preprocessor"># 0 malloc!main                                     [/home/bruening/drmemory/git/src/tests/malloc.c:164]</span>
<span class="preprocessor"></span><span class="preprocessor"># 1 libc.so.6!__libc_start_main                     [/build/buildd/eglibc-2.11.1/csu/libc-start.c:226]</span>
<span class="preprocessor"># 2 malloc!_start                                  </span>
</pre></div><p>Another common example of an invalid argument is a mismatch in calling free() versus operator delete versus operator delete[]. This will be reported as:</p>
<div class="fragment"><pre class="fragment">Error #4: INVALID HEAP ARGUMENT: allocated with <span class="keyword">operator</span> <span class="keyword">new</span>[], freed with <span class="keyword">operator</span> <span class="keyword">delete</span>
<span class="preprocessor"># 0 test_mismatch                   [cs2bug.cpp:122]</span>
<span class="preprocessor"></span><span class="preprocessor"># 1 main                            [cs2bug.cpp:139]</span>
<span class="preprocessor"></span>Note: memory was allocated here:
Note: # 0 test_mismatch                   [cs2bug.cpp:121]
Note: # 1 main                            [cs2bug.cpp:139]
</pre></div><p>For code compiled with Visual Studio, detecting such mismatches relies on having debug information. Certain Visual Studio optimizations can also preclude the ability to detect mismatches when using a static C library, so using either a Debug build of your application or linking to the dynamic C library may be required to identify these bugs. Also note that if leak counting is completely disabled via <code>-no-count_leaks</code> then the callstack of the allocation will not be reported on a mismatch.</p>
<h3><a class="anchor" id="sec_leaks">
Memory Leaks</a></h3>
<p>Dr. Memory divides all memory that is still allocated at the time it does its leak scan into 3 categories:</p>
<ol type="1">
<li>Memory that is still reachable by the application. This is NOT considered a leak. It is reported as "still-reachable allocation(s)" in Dr. Memory's summary. Many applications do not explicitly free memory whose lifetime matches the process lifetime and this is not considered an error by Dr. Memory.</li>
<li>Memory that is definitely not reachable by the application (at least, not by an aligned pointer to the start or middle of the allocated block). This is called a "leak" by Dr. Memory, as there is no way for the application to free this memory: it has lost any handle it had to the memory.</li>
<li>Memory that is reachable only via pointers to the middle of the allocation, rather than the head. This is called a "possible leak" by Dr. Memory. These may or may not be legimitate pointers to that allocation. There are several cases of known legitimate pointers that Dr. Memory recognizes using heuristics. None of these are listed as possible leaks unless the corresponding option is turned off:<ul>
<li>One class of legitimate mid-allocation pointers includes C++ arrays allocated via new[] whose elements have destructors. The new[] operators adds a header but returns to the caller the address past the header. You can suppress Dr. Memory's identification of such mid-allocation pointers, causing them to show up as possible leaks, with the <code>-no_midchunk_new_ok</code> runtime option.</li>
<li>Another class, for some C++ compilers, includes instances of a pointer to a class with multiple inheritance that is cast to one of the parents: it can end up pointing to the subobject representation in the middle of the allocation. You can suppress Dr. Memory's identification of such mid-allocation pointers, causing them to show up as possible leaks, with the <code>-no_midchunk_inheritance_ok</code> runtime option.</li>
<li>The std::string class places a <code>char</code>[] array in the middle of an allocation and points directly at it. You can suppress Dr. Memory's identification of such mid-allocation pointers, causing them to show up as possible leaks, with the <code>-no_midchunk_string_ok</code> runtime option.</li>
<li>A final example is a custom malloc wrapper that uses a header and passes a pointer offset into the result from malloc. The free wrapper subtracts from the passed-in pointer in order to compute the pointer to the head of the allocated block. You can suppress Dr. Memory's identification of such mid-allocation pointers, causing them to show up as possible leaks, with the <code>-no_midchunk_size_ok</code> runtime option.</li>
</ul>
</li>
</ol>
<p>The two categories of leaks ("leaks" and "possible leaks") are further broken down into direct and indirect leaks. An indirect leak is a heap object that is reachable by a pointer to its start address, but with all such pointers originating in leaked objects. Leaks can be thought of as trees, with the top-level object the direct leaks and all child objects indirect leaks. Dr. Memory reports the size of all the child indirect leaks for each direct leak, but does not report a detailed callstack for indirect leaks. If the direct leak is addressed, the indirect leaks should no longer be leaked, making their details unnecessary.</p>
<p>By default, Dr. Memory performs leak checking at application exit, or when a mid-run check is requested via <code>-nudge</code> (see <a class="el" href="page_using.html#sec_daemon">Applications That Do Not Exit</a>). Nudges can be used to help determine when the last pointer to an allocation was lost, if the callstack of the allocation is not sufficient to pinpoint the error in the source code. Each nudge will perform a full leak scan and by nudging periodically the first instance of a particular leak can be used to identify when the leak occurred.</p>
<p>On Windows, when HeapDestroy is called, any live allocations inside are reported as possible leaks. This can be disabled, since some applications may consider it correct behavior, with the <code>-no_check_leaks_on_destroy</code> option.</p>
<p>Dr. Memory reports the number of leaks, possible leaks, and still-reachable allocations. The callstack for the allocation of each leak and possible leak is gathered by default and listed with other errors in the results file. To also see all of the reachable allocations, use the <code>-show_reachable</code> runtime option. Reachable allocations will be in the <code>global.pid.log</code> file inside the log directory, labeled as <code>REACHABLE LEAK</code>.</p>
<p>Here are example lines from Dr. Memory's output summary:</p>
<div class="fragment"><pre class="fragment">~~Dr.M~~       9 unique,   282 total,   5860 byte(s) of leak(s)
~~Dr.M~~       0 unique,     0 total,      0 byte(s) of possible leak(s)
~~Dr.M~~     125 still-reachable allocation(s)
~~Dr.M~~          (re-run with &quot;-show_reachable&quot; for details)
</pre></div><p>There are known sources of false positives where a memory allocation may actually be reachable by the application, but Dr. Memory's algorithm will determine that it is unreachable. These cases include:</p>
<ul>
<li>The only stored pointers to an allocation are not aligned to 4 bytes.</li>
<li>The only stored pointers to an allocation are encrypted.</li>
<li>There is some custom mechanism to reach these allocations that does not involve a direct stored pointer into any part of the allocated block.</li>
</ul>
<p>One known problem comes from using glib's memory allocator. To avoid false positives when using glib, set the following environment variables when running your application:</p>
<ul>
<li>G_SLICE=always-malloc</li>
<li>G_DEBUG=gc-friendly</li>
</ul>
<h3><a class="anchor" id="sec_warning">
Warning</a></h3>
<p>Dr. Memory reports warnings about unusual memory-related conditions that an application developer might like to know about. For example:</p>
<div class="fragment"><pre class="fragment">Error #12: WARNING: heap allocation failed
@0:00:01.500 in thread 3748
<span class="preprocessor"># 0 suppress.exe!warning_test1                       [e:\derek\drmemory\git\src\tests\suppress.c:179]</span>
<span class="preprocessor"></span><span class="preprocessor"># 1 suppress.exe!test                                [e:\derek\drmemory\git\src\tests\suppress.c:282]</span>
<span class="preprocessor"></span><span class="preprocessor"># 2 suppress.exe!main                                [e:\derek\drmemory\git\src\tests\suppress.c:297]</span>
<span class="preprocessor"></span><span class="preprocessor"># 3 suppress.exe!__tmainCRTStartup                   [f:\sp\vctools\crt_bld\self_x86\crt\src\crt0.c:327]</span>
<span class="preprocessor"># 4 KERNEL32.dll!BaseProcessStart                   </span>
</pre></div><p>Dr. Memory also identifies common errors in using the Windows GDI API and reports these errors as warning. For example:</p>
<div class="fragment"><pre class="fragment">Error #15: WARNING: GDI usage error: DC 0x2d011230 that contains selected <span class="keywordtype">object</span> being deleted
<span class="preprocessor"># 0 system call NtGdiDeleteObjectApp                            </span>
<span class="preprocessor"></span><span class="preprocessor"># 1 GDI32.dll!DeleteDC                                                        +0x11     (0x76b458c5 &lt;GDI32.dll+0x158c5&gt;)</span>
<span class="preprocessor"></span><span class="preprocessor"># 2 chrome.dll!skia::BitmapPlatformDevice::BitmapPlatformDeviceData::ReleaseBitmapDC [c:\src\chromium\src\skia\ext\bitmap_platform_device_win.cc:58]</span>
<span class="preprocessor"></span><span class="preprocessor"># 3 chrome.dll!SkRefCnt::unref                                                 [c:\src\chromium\src\third_party\skia\include\core\skrefcnt.h:60]</span>
<span class="preprocessor"></span><span class="preprocessor"># 4 chrome.dll!SkRefCnt::unref                                                 [c:\src\chromium\src\third_party\skia\include\core\skrefcnt.h:60]</span>
<span class="preprocessor"></span><span class="preprocessor"># 5 chrome.dll!SkCanvas::internalRestore                                       [c:\src\chromium\src\third_party\skia\src\core\skcanvas.cpp:824]</span>
<span class="preprocessor"># 6 chrome.dll!SkCanvas::~SkCanvas                                             [c:\src\chromium\src\third_party\skia\src\core\skcanvas.cpp:449]</span>
</pre></div><p>Note that some of these GDI usage errors are best programming practices and may not result in detrimental behavior in actual usage on more recent versions of Windows. Detection of these errors can be disabled with the <code>-no_check_gdi</code> runtime option. </p>
</div>
<br>&nbsp;
<table width=100% bgcolor="#000000" cellspacing=0 cellpadding=2 border=0>
  <tr><td><table width=100% bgcolor="#0000C0" cellspacing=0 cellpadding=1 border=0>
  <tr><td><table width=100% bgcolor="#0000C0" cellspacing=0 cellpadding=1 border=0>
  <tr><td></td></tr></table></td></tr></table></td></tr></table>
<address style="text-align: center;"><small>
<br>
<img border=0 src="favicon.png"> &nbsp; Dr. Memory version 1.4.6 --- Wed Mar 7 10:13:50 2012 
&nbsp; <img border=0 src="favicon.png">
</body>
</html>
